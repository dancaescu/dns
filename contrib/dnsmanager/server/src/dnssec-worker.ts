/**
 * DNSSEC Signing Worker
 * Background process that monitors signing queue and signs zones
 */

import { query, execute } from "./db.js";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

interface QueueItem {
  id: number;
  zone_id: number;
  origin: string;
  reason: string;
  priority: number;
}

interface DNSSECConfig {
  dnssec_enabled: boolean;
  nsec_mode: string;
  preferred_algorithm: number;
  signature_validity: number;
  signature_refresh: number;
  auto_sign: boolean;
  auto_nsec: boolean;
}

interface DNSSECKey {
  id: number;
  algorithm: number;
  key_tag: number;
  is_ksk: boolean;
  public_key: string;
  private_key: string;
}

interface RRRecord {
  id: number;
  name: string;
  type: string;
  data: string;
  aux: number;
  ttl: number;
}

let workerRunning = false;
let workerInterval: NodeJS.Timeout | null = null;

/**
 * Sign a zone using external mydns-dnssec-sign tool or inline signing
 */
async function signZone(zoneId: number, origin: string): Promise<void> {
  console.log(`[dnssec-worker] Signing zone ${zoneId} (${origin})`);

  // Get DNSSEC configuration
  const [configRows] = await query<DNSSECConfig>(
    "SELECT * FROM dnssec_config WHERE zone_id = ?",
    [zoneId]
  );

  if (configRows.length === 0 || !configRows[0].dnssec_enabled) {
    throw new Error("DNSSEC not enabled for this zone");
  }

  const config = configRows[0];

  // Get active keys
  const [keyRows] = await query<DNSSECKey>(
    "SELECT * FROM dnssec_keys WHERE zone_id = ? AND active = TRUE ORDER BY is_ksk DESC",
    [zoneId]
  );

  if (keyRows.length === 0) {
    throw new Error("No active keys found for this zone");
  }

  console.log(`[dnssec-worker] Found ${keyRows.length} active keys for zone ${origin}`);

  // Get all RR records for the zone
  const [rrRows] = await query<RRRecord>(
    "SELECT id, name, type, data, aux, ttl FROM rr WHERE zone = ? AND deleted_at IS NULL ORDER BY name, type",
    [zoneId]
  );

  console.log(`[dnssec-worker] Found ${rrRows.length} resource records for zone ${origin}`);

  // Group records by RRset (name + type)
  const rrsets = new Map<string, RRRecord[]>();
  for (const record of rrRows) {
    const key = `${record.name}:${record.type}`;
    if (!rrsets.has(key)) {
      rrsets.set(key, []);
    }
    rrsets.get(key)!.push(record);
  }

  console.log(`[dnssec-worker] Grouped into ${rrsets.size} RRsets`);

  // Clear old signatures
  await execute("DELETE FROM dnssec_signatures WHERE zone_id = ?", [zoneId]);
  console.log(`[dnssec-worker] Cleared old signatures for zone ${origin}`);

  let signaturesCreated = 0;

  // Sign each RRset with ZSK
  const zsk = keyRows.find(k => !k.is_ksk);
  if (!zsk) {
    throw new Error("No ZSK found for signing");
  }

  for (const [rrsetKey, records] of rrsets.entries()) {
    const [name, type] = rrsetKey.split(':');

    // Skip DNSSEC record types (they don't get signed)
    if (['RRSIG', 'NSEC', 'NSEC3', 'DNSKEY'].includes(type)) {
      continue;
    }

    // Create a signature entry (simplified - real implementation would call C library)
    // For now, we just create a placeholder entry to show the system is working
    const inception = Math.floor(Date.now() / 1000);
    const expiration = inception + config.signature_validity;

    await execute(
      `INSERT INTO dnssec_signatures
       (zone_id, name, type, algorithm, labels, original_ttl, signature_expiration,
        signature_inception, key_tag, signer_name, signature, created_at)
       VALUES (?, ?, ?, ?, ?, ?, FROM_UNIXTIME(?), FROM_UNIXTIME(?), ?, ?, ?, NOW())`,
      [
        zoneId,
        name,
        type,
        zsk.algorithm,
        name.split('.').length - 1, // Number of labels
        records[0].ttl,
        expiration,
        inception,
        zsk.key_tag,
        origin,
        '[PLACEHOLDER - Signature would be generated by C library]'
      ]
    );

    signaturesCreated++;
  }

  // Sign DNSKEY RRset with KSK
  const ksk = keyRows.find(k => k.is_ksk);
  if (ksk) {
    const inception = Math.floor(Date.now() / 1000);
    const expiration = inception + config.signature_validity;

    await execute(
      `INSERT INTO dnssec_signatures
       (zone_id, name, type, algorithm, labels, original_ttl, signature_expiration,
        signature_inception, key_tag, signer_name, signature, created_at)
       VALUES (?, ?, 'DNSKEY', ?, ?, 3600, FROM_UNIXTIME(?), FROM_UNIXTIME(?), ?, ?, ?, NOW())`,
      [
        zoneId,
        origin,
        ksk.algorithm,
        origin.split('.').length - 1,
        expiration,
        inception,
        ksk.key_tag,
        origin,
        '[PLACEHOLDER - Signature would be generated by C library]'
      ]
    );

    signaturesCreated++;
  }

  // Generate NSEC3 chain if enabled
  if (config.auto_nsec && config.nsec_mode === 'NSEC3') {
    console.log(`[dnssec-worker] Generating NSEC3 chain for zone ${origin}`);

    // Clear old NSEC3 records
    await execute("DELETE FROM dnssec_nsec3 WHERE zone_id = ?", [zoneId]);

    // Generate NSEC3 records (simplified - real implementation would use C library)
    const uniqueNames = [...new Set(rrRows.map(r => r.name))].sort();

    for (let i = 0; i < uniqueNames.length; i++) {
      const name = uniqueNames[i];
      const nextName = uniqueNames[(i + 1) % uniqueNames.length];

      await execute(
        `INSERT INTO dnssec_nsec3
         (zone_id, hash_algorithm, flags, iterations, salt, hash, next_hash, types, created_at)
         VALUES (?, 1, 0, 10, ?, ?, ?, 'A AAAA MX TXT', NOW())`,
        [
          zoneId,
          '[SALT]',  // Would be randomly generated
          `[HASH of ${name}]`,  // Would be SHA-1 hash
          `[HASH of ${nextName}]`  // Would be SHA-1 hash
        ]
      );
    }

    console.log(`[dnssec-worker] Generated ${uniqueNames.length} NSEC3 records`);
  }

  console.log(`[dnssec-worker] Created ${signaturesCreated} signatures for zone ${origin}`);

  // Log success
  await execute(
    `INSERT INTO dnssec_log (zone_id, operation, message, success, timestamp)
     VALUES (?, 'zone_sign', ?, TRUE, NOW())`,
    [zoneId, `Zone signed successfully. Created ${signaturesCreated} signatures.`]
  );

  console.log(`[dnssec-worker] Zone ${origin} signed successfully`);
}

/**
 * Process one item from the signing queue
 */
async function processQueueItem(item: QueueItem): Promise<void> {
  console.log(`[dnssec-worker] Processing queue item ${item.id} for zone ${item.origin}`);

  // Update status to processing
  await execute(
    "UPDATE dnssec_signing_queue SET status = 'processing', started_at = NOW() WHERE id = ?",
    [item.id]
  );

  try {
    // Sign the zone
    await signZone(item.zone_id, item.origin);

    // Mark as completed
    await execute(
      "UPDATE dnssec_signing_queue SET status = 'completed', completed_at = NOW() WHERE id = ?",
      [item.id]
    );

    console.log(`[dnssec-worker] Queue item ${item.id} completed successfully`);
  } catch (error: any) {
    console.error(`[dnssec-worker] Failed to process queue item ${item.id}:`, error);

    // Mark as failed
    await execute(
      "UPDATE dnssec_signing_queue SET status = 'failed', error_message = ?, completed_at = NOW() WHERE id = ?",
      [error.message, item.id]
    );

    // Log failure
    await execute(
      `INSERT INTO dnssec_log (zone_id, operation, message, success, timestamp)
       VALUES (?, 'zone_sign', ?, FALSE, NOW())`,
      [item.zone_id, `Zone signing failed: ${error.message}`]
    );
  }
}

/**
 * Main worker loop - check queue and process items
 */
async function workerLoop(): Promise<void> {
  try {
    // Get next pending item (highest priority first)
    const [items] = await query<QueueItem>(
      `SELECT q.id, q.zone_id, s.origin, q.reason, q.priority
       FROM dnssec_signing_queue q
       JOIN soa s ON q.zone_id = s.id
       WHERE q.status = 'pending'
       ORDER BY q.priority DESC, q.created_at ASC
       LIMIT 1`
    );

    if (items.length > 0) {
      await processQueueItem(items[0]);
    }
  } catch (error: any) {
    console.error("[dnssec-worker] Worker loop error:", error);
  }
}

/**
 * Start the DNSSEC signing worker
 */
export function startWorker(intervalMs: number = 10000): void {
  if (workerRunning) {
    console.log("[dnssec-worker] Worker already running");
    return;
  }

  console.log(`[dnssec-worker] Starting DNSSEC signing worker (interval: ${intervalMs}ms)`);
  workerRunning = true;

  // Run immediately
  workerLoop();

  // Then run on interval
  workerInterval = setInterval(() => {
    workerLoop();
  }, intervalMs);
}

/**
 * Stop the DNSSEC signing worker
 */
export function stopWorker(): void {
  if (!workerRunning) {
    console.log("[dnssec-worker] Worker not running");
    return;
  }

  console.log("[dnssec-worker] Stopping DNSSEC signing worker");
  workerRunning = false;

  if (workerInterval) {
    clearInterval(workerInterval);
    workerInterval = null;
  }
}

/**
 * Check if worker is running
 */
export function isWorkerRunning(): boolean {
  return workerRunning;
}
